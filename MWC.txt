// CHESS ENGINE //

class GameState:
    def __init__(self):
        """
        Board is a 9x9 2D list. Each element has 2 characters.
        The first character represents the color: 'w' or 'b'.
        The second character represents the piece type.
        "--" represents an empty square.
        """
        self.board = [
            ["bA", "bN", "bV", "bB", "bP", "bG", "bV", "bN", "bA"],
            ["bS", "bS", "bS", "bS", "bS", "bS", "bS", "bS", "bS"],
            ["--", "--", "--", "--", "--", "--", "--", "--", "--"],
            ["--", "--", "--", "--", "--", "--", "--", "--", "--"],
            ["--", "--", "--", "--", "--", "--", "--", "--", "--"],
            ["--", "--", "--", "--", "--", "--", "--", "--", "--"],
            ["--", "--", "--", "--", "--", "--", "--", "--", "--"],
            ["wS", "wS", "wS", "wS", "wS", "wS", "wS", "wS", "wS"],
            ["wA", "wN", "wV", "wB", "wP", "wG", "wV", "wN", "wA"]
        ]
        self.moveFunctions = {
            "P": self.getPresidentMoves,
            "G": self.getGeneralMoves,
            "V": self.getViceGeneralMoves,
            "A": self.getAirMarshalMoves,
            "N": self.getNavySealMoves,
            "S": self.getSoldierMoves,
            "B": self.getArmyBattalionMoves 
        }
        self.white_to_move = True
        self.move_log = []
        
        self.white_president_location = (8, 4)
        self.black_president_location = (0, 4)
        
        self.checkmate = False
        # self.stalemate = False # <-- Removed to match index.html

    def makeMove(self, move):
        """
        Execute a move. (This is NOT for check validation)
        """
        self.board[move.start_row][move.start_col] = "--"
        self.board[move.end_row][move.end_col] = move.piece_moved
        self.move_log.append(move)
        self.white_to_move = not self.white_to_move
        
        # Update president location
        if move.piece_moved == "wP":
            self.white_president_location = (move.end_row, move.end_col)
        elif move.piece_moved == "bP":
            self.black_president_location = (move.end_row, move.end_col)
        
    def undoMove(self):
        """
        Undo the last move.
        """
        if len(self.move_log) != 0:
            move = self.move_log.pop()
            self.board[move.start_row][move.start_col] = move.piece_moved
            self.board[move.end_row][move.end_col] = move.piece_captured
            self.white_to_move = not self.white_to_move
            
            # Update president location
            if move.piece_moved == "wP":
                self.white_president_location = (move.start_row, move.start_col)
            elif move.piece_moved == "bP":
                self.black_president_location = (move.start_row, move.start_col)
                
            self.checkmate = False
            # self.stalemate = False # <-- Removed to match index.html

    def inCheck(self):
        """
        Determine if the current player is in check.
        """
        if self.white_to_move:
            return self.squareUnderAttack(self.white_president_location[0], self.white_president_location[1])
        else:
            return self.squareUnderAttack(self.black_president_location[0], self.black_president_location[1])

    def squareUnderAttack(self, row, col):
        """
        Determine if the square (row, col) is under attack by the opponent.
        """
        opponent_moves = self._getAllPossibleMovesUnchecked(not self.white_to_move)
        for move in opponent_moves:
            if move.end_row == row and move.end_col == col:
                return True
        return False

    def getValidMoves(self):
        """
        Get all valid moves considering checks.
        """
        # self.checkmate = False # <-- Removed to match JS logic (set at end)
        # self.stalemate = False # <-- Removed
        
        moves = self._getAllPossibleMovesUnchecked(self.white_to_move) # Get all moves
        
        # For each move, make the move, check if it's valid (not in check), then undo
        for i in range(len(moves) - 1, -1, -1): # Iterate backwards
            move = moves[i]
            
            # Simulate the move
            self.board[move.start_row][move.start_col] = "--"
            self.board[move.end_row][move.end_col] = move.piece_moved
            
            old_president_loc = None
            if move.piece_moved == "wP":
                old_president_loc = self.white_president_location
                self.white_president_location = (move.end_row, move.end_col)
            elif move.piece_moved == "bP":
                old_president_loc = self.black_president_location
                self.black_president_location = (move.end_row, move.end_col)

            if self.inCheck(): 
                moves.remove(move) # If it's in check, it's not a valid move

            # Undo the simulated move
            self.board[move.start_row][move.start_col] = move.piece_moved
            self.board[move.end_row][move.end_col] = move.piece_captured
            
            if move.piece_moved == "wP":
                self.white_president_location = old_president_loc
            elif move.piece_moved == "bP":
                self.black_president_location = old_president_loc
        
        # --- Logic to match index.html ---
        if len(moves) == 0 and self.inCheck():
            self.checkmate = True
        else:
            self.checkmate = False
        # --- End of matched logic ---
                
        return moves

    def _getAllPossibleMovesUnchecked(self, is_white_turn):
        """
        Get all possible moves without considering checks.
        Takes a parameter to know whose moves to get,
        so it doesn't rely on (or change) the main game state.
        
        NOTE: This function *intentionally* does not pass 'is_white_turn'
        to the move functions, to match the (buggy) logic in index.html,
        which causes them to rely on 'self.white_to_move'.
        """
        moves = []
        for row in range(9):
            for col in range(9):
                piece = self.board[row][col]
                if piece != "--" and (piece[0] == 'w' if is_white_turn else 'b'):
                    # --- MODIFIED: Removed 'is_white_turn' to match index.html ---
                    self.moveFunctions[piece[1]](row, col, moves)
        return moves

    # --- MODIFIED: All move functions below now use 'self.white_to_move' ---

    def getPresidentMoves(self, row, col, moves):
        """
        President moves one step in any direction.
        (No 'is_white_turn' was needed here)
        """
        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        for d in directions:
            end_row = row + d[0]
            end_col = col + d[1]
            if 0 <= end_row < 9 and 0 <= end_col < 9:
                end_piece = self.board[end_row][end_col]
                if end_piece == "--" or end_piece[0] != self.board[row][col][0]:
                    moves.append(Move((row, col), (end_row, end_col), self.board))

    def getGeneralMoves(self, row, col, moves):
        """
        General moves: Forward, Forward-East, Forward-West, East (Absolute),
        and one step Backward.
        """
        fwd = -1 if self.white_to_move else 1  # Forward
        back = 1 if self.white_to_move else -1 # Backward
        
        # N, NE, NW, E (relative to player, E is absolute)
        directions = [[fwd, 0], [fwd, 1], [fwd, -1], [0, 1]] 
        
        for d in directions:
            for i in range(1, 9):
                end_row = row + d[0] * i
                end_col = col + d[1] * i
                if 0 <= end_row < 9 and 0 <= end_col < 9:
                    end_piece = self.board[end_row][end_col]
                    if end_piece == "--":
                        moves.append(Move((row, col), (end_row, end_col), self.board))
                    elif end_piece[0] != self.board[row][col][0]:
                        moves.append(Move((row, col), (end_row, end_col), self.board))
                        break
                    else: # Hit a friendly piece
                        break
                else: # Off board
                    break
                    
        # One step S (relative to player)
        end_row = row + back
        end_col = col
        if 0 <= end_row < 9 and 0 <= end_col < 9:
            end_piece = self.board[end_row][end_col]
            if end_piece == "--" or end_piece[0] != self.board[row][col][0]:
                moves.append(Move((row, col), (end_row, end_col), self.board))

    def getViceGeneralMoves(self, row, col, moves):
        """
        Vice-General moves: Backward, Backward-East, Backward-West, 
        East (Absolute), West (Absolute), and one step Forward.
        """
        fwd = -1 if self.white_to_move else 1  # Forward
        back = 1 if self.white_to_move else -1 # Backward
        
        # S, SE, SW, E, W (relative to player, E/W are absolute)
        directions = [[back, 0], [back, 1], [back, -1], [0, 1], [0, -1]]
        
        for d in directions:
            for i in range(1, 9):
                end_row = row + d[0] * i
                end_col = col + d[1] * i
                if 0 <= end_row < 9 and 0 <= end_col < 9:
                    end_piece = self.board[end_row][end_col]
                    if end_piece == "--":
                        moves.append(Move((row, col), (end_row, end_col), self.board))
                    elif end_piece[0] != self.board[row][col][0]:
                        moves.append(Move((row, col), (end_row, end_col), self.board))
                        break
                    else: # Hit a friendly piece
                        break
                else: # Off board
                    break

        # One step N (relative to player)
        end_row = row + fwd
        end_col = col
        if 0 <= end_row < 9 and 0 <= end_col < 9:
            end_piece = self.board[end_row][end_col]
            if end_piece == "--" or end_piece[0] != self.board[row][col][0]:
                moves.append(Move((row, col), (end_row, end_col), self.board))

    def getAirMarshalMoves(self, row, col, moves):
        """
        Air Marshal moves: All 4 diagonals and straight Forward.
        """
        fwd = -1 if self.white_to_move else 1  # Forward
        back = 1 if self.white_to_move else -1 # Backward
        
        # NE, NW, SE, SW, N (relative to player)
        directions = [[fwd, 1], [fwd, -1], [back, 1], [back, -1], [fwd, 0]] 
        
        for d in directions:
            for i in range(1, 9):
                end_row = row + d[0] * i
                end_col = col + d[1] * i
                if 0 <= end_row < 9 and 0 <= end_col < 9:
                    end_piece = self.board[end_row][end_col]
                    if end_piece == "--":
                        moves.append(Move((row, col), (end_row, end_col), self.board))
                    elif end_piece[0] != self.board[row][col][0]:
                        moves.append(Move((row, col), (end_row, end_col), self.board))
                        break
                    else: # Hit a friendly piece
                        break
                else: # Off board
                    break

    def getNavySealMoves(self, row, col, moves):
        """
        Navy Seal moves: 2 steps diagonally (NE, NW, SE, SW).
        (No 'is_white_turn' was needed here)
        """
        directions = [(-2, 2), (2, 2), (2, -2), (-2, -2)]
        for d in directions:
            end_row = row + d[0]
            end_col = col + d[1]
            if 0 <= end_row < 9 and 0 <= end_col < 9:
                end_piece = self.board[end_row][end_col]
                if end_piece == "--" or end_piece[0] != self.board[row][col][0]:
                    moves.append(Move((row, col), (end_row, end_col), self.board))

    def getArmyBattalionMoves(self, row, col, moves):
        """
        Army Battalion moves: N, S, E, W.
        (No 'is_white_turn' was needed here)
        """
        directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        for d in directions:
            for i in range(1, 9):
                end_row = row + d[0] * i
                end_col = col + d[1] * i
                if 0 <= end_row < 9 and 0 <= end_col < 9:
                    end_piece = self.board[end_row][end_col]
                    if end_piece == "--":
                        moves.append(Move((row, col), (end_row, end_col), self.board))
                    elif end_piece[0] != self.board[row][col][0]:
                        moves.append(Move((row, col), (end_row, end_col), self.board))
                        break
                    else: # Hit a friendly piece
                        break
                else: # Off board
                    break

    def getSoldierMoves(self, row, col, moves):
        """
        Soldier (Pawn) moves.
        """
        if self.white_to_move: # White moves UP (row index decreases)
            if row - 1 >= 0 and self.board[row - 1][col] == "--":
                moves.append(Move((row, col), (row - 1, col), self.board))
                if row == 7 and self.board[row - 2][col] == "--": # 2-step from row 7
                    moves.append(Move((row, col), (row - 2, col), self.board))
            if row - 1 >= 0 and col - 1 >= 0:
                if self.board[row - 1][col - 1][0] == 'b': 
                    moves.append(Move((row, col), (row - 1, col - 1), self.board))
            if row - 1 >= 0 and col + 1 < 9:
                if self.board[row - 1][col + 1][0] == 'b': 
                    moves.append(Move((row, col), (row - 1, col + 1), self.board))
        else: # Black moves DOWN (row index increases)
            if row + 1 < 9 and self.board[row + 1][col] == "--":
                moves.append(Move((row, col), (row + 1, col), self.board))
                if row == 1 and self.board[row + 2][col] == "--": # 2-step from row 1
                    moves.append(Move((row, col), (row + 2, col), self.board))
            if row + 1 < 9 and col - 1 >= 0:
                if self.board[row + 1][col - 1][0] == 'w': 
                    moves.append(Move((row, col), (row + 1, col - 1), self.board))
            if row + 1 < 9 and col + 1 < 9:
                if self.board[row + 1][col + 1][0] == 'w': 
                    moves.append(Move((row, col), (row + 1, col + 1), self.board))


class Move:
    def __init__(self, start_sq, end_sq, board):
        self.start_row = start_sq[0]
        self.start_col = start_sq[1]
        self.end_row = end_sq[0]
        self.end_col = end_sq[1]
        self.piece_moved = board[self.start_row][self.start_col]
        self.piece_captured = board[self.end_row][self.end_col]
        self.moveID = self.start_row * 1000 + self.start_col * 100 + self.end_row * 10 + self.end_col

    def __eq__(self, other):
        if isinstance(other, Move):
            return self.moveID == other.moveID
        return False





// CHESS UI //

import tkinter as tk
from tkinter import messagebox
from PIL import Image, ImageTk
from pathlib import Path
import time
import chessengine as ChessEngine
from chessengine import GameState, Move
import traceback # <-- Import traceback to show errors

BOARD_WIDTH = BOARD_HEIGHT = 576  
DIMENSION = 9
SQUARE_SIZE = BOARD_HEIGHT // DIMENSION
IMAGES = {}


# --- FIX: Updated Piece Info descriptions to match index.html ---
PIECE_INFO = {
    "P": "President (P):\nMoves one step in any direction.",
    "G": "General (G):\nMoves across the board (N, NE, NW, E) and one step (S).",
    "V": "Vice-General (V):\nMoves across the board (S, SE, SW, E, W) and one step (N).",
    "A": "Air Marshal (A):\nMoves across the board (NE, NW, SE, SW, N).",
    "N": "Navy Seal (N):\nJumps two steps diagonally.",
    "B": "Army Battalion (B):\nMoves across the board (N, S, E, W), like a Rook.",
    "S": "Soldier (S):\nMoves like a standard Pawn. One step forward, two on first move. Captures diagonally forward."
}

class ChessUI:
    def __init__(self, root):
        self.root = root
        self.root.title("9x9 Chess Game")
        self.root.configure(bg="#696561")
        
        self.game_state = GameState()
        self.valid_moves = [] # Start with empty list
        self.state = {"selected": (), "clicks": []}
        self.game_over = False 
        
        self.player_time = 600
        self.opponent_time = 600
        self.timer_running = False
        self.last_time_update = time.time()
        self.move_log = []
        self.move_index = -1
        self.first_move_made = False

        # Main content frame
        main_frame = tk.Frame(root, bg="#696561")
        main_frame.pack(fill="both", expand=True)

        # Create canvas
        self.canvas = tk.Canvas(main_frame, width=BOARD_WIDTH, height=BOARD_HEIGHT)
        self.canvas.pack(side="left", padx=10, pady=10)

        frame_sidebar = tk.Frame(main_frame, bg="#f5dea9", width=250)
        frame_sidebar.pack(side="right", fill="y", padx=10, pady=10)

        # Timer labels
        timer_frame = tk.Frame(frame_sidebar, bg="#f5dea9")
        timer_frame.pack(pady=10)
        self.player_time_label = tk.Label(timer_frame, text="Player Time: 10:00", font=("Arial", 12), bg="#c27421", fg="#f5dea9")
        self.player_time_label.pack(pady=5, padx=10)
        self.opponent_time_label = tk.Label(timer_frame, text="Opponent Time: 10:00", font=("Arial", 12), bg="#c27421", fg="#f5dea9")
        self.opponent_time_label.pack(pady=5, padx=10)

        # Buttons
        button_frame = tk.Frame(frame_sidebar, bg="#f5dea9")
        button_frame.pack(pady=10)
        self.new_game_button = tk.Button(button_frame, text="New Game", command=self.newGame, bg="#c27421", fg="#f5dea9")
        self.new_game_button.pack(pady=5)
        self.undo_button = tk.Button(button_frame, text="Undo", command=self.undoMove, bg="#c27421", fg="#f5dea9")
        self.undo_button.pack(pady=5)
        self.redo_button = tk.Button(button_frame, text="Redo", command=self.redoMove, bg="#c27421", fg="#f5dea9")
        self.redo_button.pack(pady=5)

        #Info Panel
        info_frame = tk.Frame(frame_sidebar, bg="#f5dea9")
        info_frame.pack(pady=10, padx=10, fill="both", expand=True)
        info_title = tk.Label(info_frame, text="Piece Info", font=("Arial", 14, "bold"), bg="#f5dea9")
        info_title.pack(pady=5)
        self.info_text = tk.Text(info_frame, height=10, width=28, wrap="word", font=("Arial", 10), bg="#fcf3d9", relief="sunken", borderwidth=1)
        self.info_text.pack(fill="both", expand=True, padx=5, pady=5)
        self.info_text.insert("1.0", "Click on a piece to see its move description.")
        self.info_text.config(state="disabled")

        # Load images and initialize board
        if self.loadImages():
            
            # --- DEBUG: Wrap initial logic in try...except ---
            try:
                self.valid_moves = self.game_state.getValidMoves()
                # --- MODIFIED: Removed stalemate check ---
                if self.game_state.checkmate:
                    self.game_over = True
                
                self.drawBoard()
                self.drawPieces(self.game_state.board)
                self.canvas.bind("<Button-1>", self.onSquareClick_Safe) # Bind to safe wrapper
            except Exception as e:
                self.show_error(e)
        else:
            self.root.destroy()
            return

    # --- DEBUG: Add a function to show errors ---
    def show_error(self, e):
        """Displays an error message box with details."""
        error_message = f"An error occurred:\n\n{type(e).__name__}: {e}\n\nTraceback:\n{traceback.format_exc()}"
        print(error_message) # Print to console as well
        messagebox.showerror("Runtime Error", error_message)

    def loadImages(self):
        """
        Load images for the pieces.
        """
        pieces = ['wP', 'wG', 'wV', 'wA', 'wN', 'wS', 'wB',
                  'bP', 'bG', 'bV', 'bA', 'bN', 'bS', 'bB']
        try:
            image_path = Path("images") 
            for piece in pieces:
                img_path = image_path / f"{piece}.png"
                if img_path.exists():
                    img = Image.open(img_path)
                    padding = 4 
                    img_size = SQUARE_SIZE - padding * 2
                    img = img.resize((img_size, img_size), Image.Resampling.LANCZOS)
                    IMAGES[piece] = ImageTk.PhotoImage(img)
                else:
                    raise FileNotFoundError(f"Image not found: {img_path}")
        except Exception as e:
            if isinstance(e, FileNotFoundError):
                 messagebox.showerror("Error", f"Failed to load image: {e.filename}\n\nMake sure you have an 'images' folder in the same directory with all 14 piece PNGs (e.g., wP.png, bP.png).")
            else:
                messagebox.showerror("Error", f"Failed to load chess pieces: {str(e)}")
            return False
        return True

    def drawBoard(self):
        """
        Draw the 9x9 chessboard.
        """
        colors = ["#f0d9b5", "#b58863"]
        for row in range(DIMENSION):
            for col in range(DIMENSION):
                color = colors[(row + col) % 2]
                self.canvas.create_rectangle(
                    col * SQUARE_SIZE, row * SQUARE_SIZE,
                    (col + 1) * SQUARE_SIZE, (row + 1) * SQUARE_SIZE,
                    fill=color, outline=""
                )

    def drawPieces(self, board):
        """
        Draw the pieces on the board.
        """
        self.canvas.delete("pieces")
        for row in range(DIMENSION):
            for col in range(DIMENSION):
                piece = board[row][col]
                if piece != "--" and piece in IMAGES:
                    x = col * SQUARE_SIZE + SQUARE_SIZE // 2
                    y = row * SQUARE_SIZE + SQUARE_SIZE // 2
                    self.canvas.create_image(
                        x, y, image=IMAGES[piece], anchor="c", tags="pieces"
                    )

    def highlightEmptySquares(self, moves):
        """
        Draws dots on valid empty squares.
        """
        dot_radius = SQUARE_SIZE // 6
        for move in moves:
            if move.piece_captured == "--":
                end_row, end_col = move.end_row, move.end_col
                center_x = end_col * SQUARE_SIZE + SQUARE_SIZE // 2
                center_y = end_row * SQUARE_SIZE + SQUARE_SIZE // 2

                self.canvas.create_oval(
                    center_x - dot_radius, center_y - dot_radius,
                    center_x + dot_radius, center_y + dot_radius,
                    fill="#bbbbbb", 
                    outline=""
                )

    def highlightCaptureSquares(self, moves):
        """
        Draws rings on valid capture squares.
        """
        ring_thickness = 3 
        for move in moves:
            if move.piece_captured != "--":
                end_row, end_col = move.end_row, move.end_col
                self.canvas.create_oval(
                    end_col * SQUARE_SIZE + ring_thickness, 
                    end_row * SQUARE_SIZE + ring_thickness,
                    (end_col + 1) * SQUARE_SIZE - ring_thickness, 
                    (end_row + 1) * SQUARE_SIZE - ring_thickness,
                    outline="#bbbbbb", 
                    width=ring_thickness
                )
            
    def updateInfoPanel(self, piece=None):
        """
        Updates the piece info panel with the description of the selected piece.
        """
        self.info_text.config(state="normal")
        self.info_text.delete("1.0", "end")
        if piece and piece != "--":
            piece_type = piece[1]
            description = PIECE_INFO.get(piece_type, "No description available for this piece.")
            self.info_text.insert("1.0", description)
        else:
            self.info_text.insert("1.0", "Click on a piece to see its move description.")
        self.info_text.config(state="disabled")

    # --- DEBUG: Create a 'safe' wrapper for the click handler ---
    def onSquareClick_Safe(self, event):
        """Wraps the main click handler in a try...except block."""
        try:
            self.onSquareClick(event)
        except Exception as e:
            self.show_error(e)

    def onSquareClick(self, event):
        """
        Handle square clicks. (Actual logic)
        """
        
        if self.game_over:
            return

        col = event.x // SQUARE_SIZE
        row = event.y // SQUARE_SIZE
        if not (0 <= row < DIMENSION and 0 <= col < DIMENSION):
            return
        square = (row, col)

        if self.state["selected"]:  # A piece is already selected
            selected_square = self.state["selected"]
            self.state["selected"] = () # Deselect for now
            self.state["clicks"] = []

            if square == selected_square: # Clicked same square
                self.drawBoard()
                self.drawPieces(self.game_state.board)
                self.updateInfoPanel() # Clear info panel
                return # Just deselect, board is cleared of highlights

            # Check if it's a valid move
            move = Move(selected_square, square, self.game_state.board)
            valid_move_found = None
            for v_move in self.valid_moves:
                if move == v_move:
                    valid_move_found = v_move
                    break

            if valid_move_found:
                self.game_state.makeMove(valid_move_found)
                self.move_log = self.move_log[:self.move_index + 1]
                self.move_log.append(valid_move_found)
                self.move_index += 1
                if not self.first_move_made:
                    self.first_move_made = True
                    self.startTimer()
                
                self.valid_moves = self.game_state.getValidMoves() # Get next player's moves
                self.drawBoard()
                self.drawPieces(self.game_state.board)
                self.updateInfoPanel() # Clear info panel
                
                if self.game_state.checkmate:
                    self.game_over = True
                    self.timer_running = False 
                    winner = "Black" if self.game_state.white_to_move else "White"
                    messagebox.showinfo("Game Over", f"Checkmate! {winner} wins.")
                # --- MODIFIED: Removed stalemate check ---
                # elif self.game_state.stalemate:
                #     self.game_over = True
                #     self.timer_running = False 
                #     messagebox.showinfo("Game Over", "Stalemate! The game is a draw.")
                        
                return  # Exit after making a move
        
        
        piece = self.game_state.board[row][col]
        
        if piece != "--" and (piece[0] == 'w' if self.game_state.white_to_move else 'b'):
            self.state["selected"] = square
            self.state["clicks"] = [square]
            
            valid_moves_for_piece = [move for move in self.valid_moves if move.start_row == row and move.start_col == col]
            
            empty_square_moves = [m for m in valid_moves_for_piece if m.piece_captured == "--"]
            capture_moves = [m for m in valid_moves_for_piece if m.piece_captured != "--"]

            self.drawBoard()
            self.highlightEmptySquares(empty_square_moves) 
            self.drawPieces(self.game_state.board)
            self.highlightCaptureSquares(capture_moves) 
            self.updateInfoPanel(piece) 
        else:
            self.drawBoard()
            self.drawPieces(self.game_state.board)
            self.updateInfoPanel() 
            self.state["selected"] = () 

    def startTimer(self):
        """
        Start the timer.
        """
        if not self.timer_running and not self.game_over:
            self.timer_running = True
            self.last_time_update = time.time()
            self.updateTimer()

    def updateTimer(self):
        """
        Update the timer.
        """
        if self.timer_running and not self.game_over:
            current_time = time.time()
            elapsed_time = current_time - self.last_time_update
            self.last_time_update = current_time
            if self.game_state.white_to_move:
                self.player_time -= elapsed_time
            else:
                self.opponent_time -= elapsed_time
                
            if self.player_time <= 0 or self.opponent_time <= 0:
                self.player_time = max(0, self.player_time)
                self.opponent_time = max(0, self.opponent_time)
                self.timer_running = False
                self.game_over = True
                winner = "Black" if self.player_time <= 0 else "White"
                messagebox.showinfo("Game Over", f"Time's up! {winner} wins!")
            
            self.player_time_label.config(text=f"Player Time: {int(self.player_time // 60):02d}:{int(self.player_time % 60):02d}")
            self.opponent_time_label.config(text=f"Opponent Time: {int(self.opponent_time // 60):02d}:{int(self.opponent_time % 60):02d}")
            
            if self.timer_running and not self.game_over:
                self.root.after(1000, self.updateTimer)

    def newGame(self):
        """
        Start a new game.
        """
        # --- DEBUG: Wrap in try...except ---
        try:
            self.game_state = GameState()
            self.valid_moves = self.game_state.getValidMoves()
            self.state = {"selected": (), "clicks": []}
            self.player_time = 600
            self.opponent_time = 600
            self.timer_running = False
            self.last_time_update = time.time()
            self.move_log = []
            self.move_index = -1
            self.first_move_made = False
            
            # --- MODIFIED: Removed stalemate check ---
            if self.game_state.checkmate:
                self.game_over = True
            else:
                self.game_over = False 
                
            self.drawBoard()
            self.drawPieces(self.game_state.board)
            self.player_time_label.config(text="Player Time: 10:00")
            self.opponent_time_label.config(text="Opponent Time: 10:00")
            self.updateInfoPanel() 
        except Exception as e:
            self.show_error(e)

    def undoMove(self):
        """
        Undo the last move.
        """
        # --- DEBUG: Wrap in try...except ---
        try:
            if self.move_index >= 0:
                self.timer_running = False 
                
                self.game_state.undoMove()
                self.move_index -= 1
                self.valid_moves = self.game_state.getValidMoves()
                self.drawBoard()
                self.drawPieces(self.game_state.board)
                self.updateInfoPanel() 
                self.game_over = False 
                
                if self.move_index == -1:
                    self.first_move_made = False
                elif not self.game_over: 
                    self.startTimer() 
        except Exception as e:
            self.show_error(e)

    def redoMove(self):
        """
        Redo the last undone move.
        """
        # --- DEBUG: Wrap in try...except ---
        try:
            if self.move_index < len(self.move_log) - 1:
                self.timer_running = False 
                
                self.move_index += 1
                self.game_state.makeMove(self.move_log[self.move_index]) 
                self.valid_moves = self.game_state.getValidMoves()
                self.drawBoard()
                self.drawPieces(self.game_state.board)
                self.updateInfoPanel() 
                
                if not self.game_over:
                    self.startTimer() 
                
                if self.game_state.checkmate:
                    self.game_over = True
                    self.timer_running = False
                    winner = "Black" if self.game_state.white_to_move else "White"
                    messagebox.showinfo("Game Over", f"Checkmate! {winner} wins.")
                # --- MODIFIED: Removed stalemate check ---
                # elif self.game_state.stalemate:
                #     self.game_over = True
                #     self.timer_running = False
                #     messagebox.showinfo("Game Over", "Stalemate! The game is a draw.")
        except Exception as e:
            self.show_error(e)


def main():
    """
    Main function to run the game.
    """
    root = tk.Tk()
    ChessUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()



// In HTML CSS //

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>9x9 Chess Game</title>
    <style>
        /* Basic page styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #333;
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            min-height: 100vh;
        }

        /* Main container for board and sidebar */
        .game-container {
            display: flex;
            flex-wrap: wrap; /* Allows sidebar to stack on small screens */
            justify-content: center;
            gap: 20px;
        }

        /* The game board canvas */
        #chessCanvas {
            background-color: #f0d9b5;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            max-width: 100%;
            height: auto;
        }

        /* Sidebar for controls and info */
        .sidebar {
            width: 220px;
            min-width: 220px;
            background-color: #f5dea9;
            color: #333;
            border-radius: 8px;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Timer labels */
        .timer {
            font-size: 1.1em;
            font-weight: 600;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            background-color: #c27421;
            color: #f5dea9;
        }

        /* Control buttons */
        .sidebar button {
            font-size: 1em;
            font-weight: 500;
            padding: 12px;
            border: none;
            border-radius: 6px;
            background-color: #c27421;
            color: #f5dea9;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .sidebar button:hover {
            background-color: #a8641b;
        }

        /* Piece info box */
        .info-box {
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 12px;
            height: 150px;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.5;
        }
        .info-box h3 {
            margin-top: 0;
            padding-bottom: 5px;
            border-bottom: 2px solid #eee;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <!-- The board will be drawn here by JavaScript -->
        <canvas id="chessCanvas"></canvas>

        <!-- Sidebar with controls and info -->
        <div class="sidebar">
            <div id="player-time" class="timer">Player Time: 10:00</div>
            <div id="opponent-time" class="timer">Opponent Time: 10:00</div>
            
            <button id="new-game-btn">New Game</button>
            <button id="undo-btn">Undo</button>
            <button id="redo-btn">Redo</button>
            
            <div class="info-box">
                <h3 id="info-piece-name">Piece Info</h3>
                <p id="info-piece-desc">Click on a piece to see its move description.</p>
            </div>
        </div>
    </div>

    <script>
        // --- 1. GAME CONSTANTS AND STATE ---
        const BOARD_WIDTH = 576;
        const BOARD_HEIGHT = 576;
        const DIMENSION = 9;
        const SQUARE_SIZE = BOARD_WIDTH / DIMENSION;
        const IMAGES = {};
        
        // Piece Info Descriptions (Ported from chessui.py)
        const PIECE_INFO = {
            "P": { name: "President", desc: "Moves one step in any direction." },
            "G": { name: "General", desc: "Moves across the board (N, NE, NW, E) and one step (S)." },
            "V": { name: "Vice-General", desc: "Moves across the board (S, SE, SW, E, W) and one step (N)." },
            "A": { name: "Air Marshal", desc: "Moves across the board (NE, NW, SE, SW, N)." },
            "N": { name: "Navy Seal", desc: "Jumps two steps diagonally." },
            "S": { name: "Soldier", desc: "Moves like a standard Pawn. One step forward, two on first move. Captures diagonally forward." },
            "B": { name: "Army Battalion", desc: "Moves across the board (N, S, E, W), like a Rook." },
            "default": { name: "Piece Info", desc: "Click on a piece to see its move description." }
        };
        
        // --- 2. GAME ENGINE (Ported from chessengine.py) ---

        /**
         * Represents a single move
         */
        class Move {
            constructor(startSq, endSq, board) {
                this.startRow = startSq[0];
                this.startCol = startSq[1];
                this.endRow = endSq[0];
                this.endCol = endSq[1];
                this.pieceMoved = board[this.startRow][this.startCol];
                this.pieceCaptured = board[this.endRow][this.endCol];
                this.moveID = this.startRow * 1000 + this.startCol * 100 + this.endRow * 10 + this.endCol;
            }

            equals(other) {
                if (other instanceof Move) {
                    return this.moveID === other.moveID;
                }
                return false;
            }
        }

        /**
         * Represents the entire game state and logic
         */
        class GameState {
            constructor() {
                this.board = [
                    ["bA", "bN", "bV", "bB", "bP", "bG", "bV", "bN", "bA"],
                    ["bS", "bS", "bS", "bS", "bS", "bS", "bS", "bS", "bS"],
                    ["--", "--", "--", "--", "--", "--", "--", "--", "--"],
                    ["--", "--", "--", "--", "--", "--", "--", "--", "--"],
                    ["--", "--", "--", "--", "--", "--", "--", "--", "--"],
                    ["--", "--", "--", "--", "--", "--", "--", "--", "--"],
                    ["--", "--", "--", "--", "--", "--", "--", "--", "--"],
                    ["wS", "wS", "wS", "wS", "wS", "wS", "wS", "wS", "wS"],
                    ["wA", "wN", "wV", "wB", "wP", "wG", "wV", "wN", "wA"]
                ];
                
                // JS equivalent of the moveFunctions dictionary
                this.moveFunctions = {
                    "P": this.getPresidentMoves,
                    "G": this.getGeneralMoves,
                    "V": this.getViceGeneralMoves,
                    "A": this.getAirMarshalMoves,
                    "N": this.getNavySealMoves,
                    "S": this.getSoldierMoves,
                    "B": this.getArmyBattalionMoves
                };
                
                this.whiteToMove = true;
                this.moveLog = [];
                this.whitePresidentLocation = [8, 4];
                this.blackPresidentLocation = [0, 4];
                this.checkmate = false;
            }

            makeMove(move) {
                this.board[move.startRow][move.startCol] = "--";
                this.board[move.endRow][move.endCol] = move.pieceMoved;
                this.moveLog.push(move);
                this.whiteToMove = !this.whiteToMove;

                if (move.pieceMoved === "wP") {
                    this.whitePresidentLocation = [move.endRow, move.endCol];
                } else if (move.pieceMoved === "bP") {
                    this.blackPresidentLocation = [move.endRow, move.endCol];
                }
            }

            undoMove() {
                if (this.moveLog.length === 0) return;
                
                const move = this.moveLog.pop();
                this.board[move.startRow][move.startCol] = move.pieceMoved;
                this.board[move.endRow][move.endCol] = move.pieceCaptured;
                this.whiteToMove = !this.whiteToMove;

                if (move.pieceMoved === "wP") {
                    this.whitePresidentLocation = [move.startRow, move.startCol];
                } else if (move.pieceMoved === "bP") {
                    this.blackPresidentLocation = [move.startRow, move.startCol];
                }
                this.checkmate = false;
            }

            inCheck() {
                if (this.whiteToMove) {
                    return this.squareUnderAttack(this.whitePresidentLocation[0], this.whitePresidentLocation[1]);
                } else {
                    return this.squareUnderAttack(this.blackPresidentLocation[0], this.blackPresidentLocation[1]);
                }
            }

            squareUnderAttack(row, col) {
                const opponentMoves = this._getAllPossibleMovesUnchecked(!this.whiteToMove);
                for (const move of opponentMoves) {
                    if (move.endRow === row && move.endCol === col) {
                        return true;
                    }
                }
                return false;
            }

            getValidMoves() {
                const moves = this._getAllPossibleMovesUnchecked(this.whiteToMove);
                
                for (let i = moves.length - 1; i >= 0; i--) {
                    const move = moves[i];
                    
                    // Simulate the move
                    this.board[move.startRow][move.startCol] = "--";
                    this.board[move.endRow][move.endCol] = move.pieceMoved;
                    
                    let oldPresidentLoc = null;
                    if (move.pieceMoved === "wP") {
                        oldPresidentLoc = this.whitePresidentLocation;
                        this.whitePresidentLocation = [move.endRow, move.endCol];
                    } else if (move.pieceMoved === "bP") {
                        oldPresidentLoc = this.blackPresidentLocation;
                        this.blackPresidentLocation = [move.endRow, move.endCol];
                    }

                    if (this.inCheck()) {
                        moves.splice(i, 1); // Remove invalid move
                    }
                    
                    // Undo simulated move
                    this.board[move.startRow][move.startCol] = move.pieceMoved;
                    this.board[move.endRow][move.endCol] = move.pieceCaptured;
                    
                    if (move.pieceMoved === "wP") {
                        this.whitePresidentLocation = oldPresidentLoc;
                    } else if (move.pieceMoved === "bP") {
                        this.blackPresidentLocation = oldPresidentLoc;
                    }
                }

                // After filtering, check for checkmate
                if (moves.length === 0 && this.inCheck()) {
                    this.checkmate = true;
                } else {
                    this.checkmate = false;
                }
                
                return moves;
            }

            _getAllPossibleMovesUnchecked(isWhiteTurn) {
                const moves = [];
                for (let r = 0; r < DIMENSION; r++) {
                    for (let c = 0; c < DIMENSION; c++) {
                        const piece = this.board[r][c];
                        if (piece !== "--" && (piece[0] === 'w' ? isWhiteTurn : !isWhiteTurn)) {
                            // Call the correct move function, binding 'this'
                            this.moveFunctions[piece[1]].call(this, r, c, moves);
                        }
                    }
                }
                return moves;
            }
            
            // --- Piece Move Functions (Ported) ---
            
            getPresidentMoves(row, col, moves) {
                const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                for (const d of directions) {
                    const endRow = row + d[0];
                    const endCol = col + d[1];
                    if (0 <= endRow && endRow < DIMENSION && 0 <= endCol && endCol < DIMENSION) {
                        const endPiece = this.board[endRow][endCol];
                        if (endPiece === "--" || endPiece[0] !== this.board[row][col][0]) {
                            moves.push(new Move([row, col], [endRow, endCol], this.board));
                        }
                    }
                }
            }

            getGeneralMoves(row, col, moves) {
                // --- FIX: Make directions relative to player ---
                const fwd = this.whiteToMove ? -1 : 1;  // Forward
                const back = this.whiteToMove ? 1 : -1; // Backward
                
                // N, NE, NW, E (relative to player)
                const directions = [[fwd, 0], [fwd, 1], [fwd, -1], [0, 1]]; 
                
                for (const d of directions) {
                    for (let i = 1; i < DIMENSION; i++) {
                        const endRow = row + d[0] * i;
                        const endCol = col + d[1] * i;
                        if (0 <= endRow && endRow < DIMENSION && 0 <= endCol && endCol < DIMENSION) {
                            const endPiece = this.board[endRow][endCol];
                            if (endPiece === "--") {
                                moves.push(new Move([row, col], [endRow, endCol], this.board));
                            } else if (endPiece[0] !== this.board[row][col][0]) {
                                moves.push(new Move([row, col], [endRow, endCol], this.board));
                                break;
                            } else {
                                break;
                            }
                        // --- BUGFIX: Added 'else' to break on hitting board edge ---
                        } else {
                            break;
                        }
                    } // --- BUGFIX: Closed inner for loop ---
                } // --- BUGFIX: Closed outer for loop ---

                // One step S (relative to player)
                const endRow = row + back;
                const endCol = col;
                if (0 <= endRow && endRow < DIMENSION && 0 <= endCol && endCol < DIMENSION) {
                    const endPiece = this.board[endRow][endCol];
                    if (endPiece === "--" || endPiece[0] !== this.board[row][col][0]) {
                        moves.push(new Move([row, col], [endRow, endCol], this.board));
                    }
                }
            }
            
            getViceGeneralMoves(row, col, moves) {
                // --- FIX: Make directions relative to player ---
                const fwd = this.whiteToMove ? -1 : 1;  // Forward
                const back = this.whiteToMove ? 1 : -1; // Backward

                // S, SE, SW, E, W (relative to player)
                const directions = [[back, 0], [back, 1], [back, -1], [0, 1], [0, -1]];
                
                for (const d of directions) {
                    for (let i = 1; i < DIMENSION; i++) {
                        const endRow = row + d[0] * i;
                        const endCol = col + d[1] * i;
                        if (0 <= endRow && endRow < DIMENSION && 0 <= endCol && endCol < DIMENSION) {
                            const endPiece = this.board[endRow][endCol];
                            if (endPiece === "--") {
                                moves.push(new Move([row, col], [endRow, endCol], this.board));
                            } else if (endPiece[0] !== this.board[row][col][0]) {
                                moves.push(new Move([row, col], [endRow, endCol], this.board));
                                break;
                            } else {
                                break;
                            }
                        // --- BUGFIX: Added 'else' to break on hitting board edge ---
                        } else {
                            break;
                        }
                    } // --- BUGFIX: Closed inner for loop ---
                } // --- BUGFIX: Closed outer for loop ---

                // One step N (relative to player)
                const endRow = row + fwd;
                const endCol = col;
                if (0 <= endRow && endRow < DIMENSION && 0 <= endCol && endCol < DIMENSION) {
                    const endPiece = this.board[endRow][endCol];
                    if (endPiece === "--" || endPiece[0] !== this.board[row][col][0]) {
                        moves.push(new Move([row, col], [endRow, endCol], this.board));
                    }
                }
            }

            getAirMarshalMoves(row, col, moves) {
                // --- FIX: Make directions relative to player ---
                const fwd = this.whiteToMove ? -1 : 1;  // Forward
                const back = this.whiteToMove ? 1 : -1; // Backward

                // NE, NW, SE, SW, N (relative to player)
                const directions = [[fwd, 1], [fwd, -1], [back, 1], [back, -1], [fwd, 0]]; 
                
                for (const d of directions) {
                    for (let i = 1; i < DIMENSION; i++) {
                        const endRow = row + d[0] * i;
                        const endCol = col + d[1] * i;
                        if (0 <= endRow && endRow < DIMENSION && 0 <= endCol && endCol < DIMENSION) {
                            const endPiece = this.board[endRow][endCol];
                            if (endPiece === "--") {
                                moves.push(new Move([row, col], [endRow, endCol], this.board));
                            } else if (endPiece[0] !== this.board[row][col][0]) {
                                moves.push(new Move([row, col], [endRow, endCol], this.board));
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }
            }
            
            getNavySealMoves(row, col, moves) {
                const directions = [[-2, 2], [2, 2], [2, -2], [-2, -2]];
                for (const d of directions) {
                    const endRow = row + d[0];
                    const endCol = col + d[1];
                    if (0 <= endRow && endRow < DIMENSION && 0 <= endCol && endCol < DIMENSION) {
                        const endPiece = this.board[endRow][endCol];
                        if (endPiece === "--" || endPiece[0] !== this.board[row][col][0]) {
                            moves.push(new Move([row, col], [endRow, endCol], this.board));
                        }
                    }
                }
            }

            getArmyBattalionMoves(row, col, moves) {
                const directions = [[-1, 0], [1, 0], [0, 1], [0, -1]];
                for (const d of directions) {
                    for (let i = 1; i < DIMENSION; i++) {
                        const endRow = row + d[0] * i;
                        const endCol = col + d[1] * i;
                        if (0 <= endRow && endRow < DIMENSION && 0 <= endCol && endCol < DIMENSION) {
                            const endPiece = this.board[endRow][endCol];
                            if (endPiece === "--") {
                                moves.push(new Move([row, col], [endRow, endCol], this.board));
                            } else if (endPiece[0] !== this.board[row][col][0]) {
                                moves.push(new Move([row, col], [endRow, endCol], this.board));
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }
            }
            
            getSoldierMoves(row, col, moves) {
                if (this.whiteToMove) {
                    if (row - 1 >= 0 && this.board[row - 1][col] === "--") {
                        moves.push(new Move([row, col], [row - 1, col], this.board));
                        if (row === 7 && this.board[row - 2][col] === "--") {
                            moves.push(new Move([row, col], [row - 2, col], this.board));
                        }
                    }
                    if (row - 1 >= 0 && col - 1 >= 0 && this.board[row - 1][col - 1][0] === 'b') {
                        moves.push(new Move([row, col], [row - 1, col - 1], this.board));
                    }
                    if (row - 1 >= 0 && col + 1 < DIMENSION && this.board[row - 1][col + 1][0] === 'b') {
                        moves.push(new Move([row, col], [row - 1, col + 1], this.board));
                    }
                } else { // Black to move
                    if (row + 1 < DIMENSION && this.board[row + 1][col] === "--") {
                        moves.push(new Move([row, col], [row + 1, col], this.board));
                        if (row === 1 && this.board[row + 2][col] === "--") {
                            moves.push(new Move([row, col], [row + 2, col], this.board));
                        }
                    }
                    if (row + 1 < DIMENSION && col - 1 >= 0 && this.board[row + 1][col - 1][0] === 'w') {
                        moves.push(new Move([row, col], [row + 1, col - 1], this.board));
                    }
                    if (row + 1 < DIMENSION && col + 1 < DIMENSION && this.board[row + 1][col + 1][0] === 'w') {
                        moves.push(new Move([row, col], [row + 1, col + 1], this.board));
                    }
                }
            }
        }

        // --- 3. UI LOGIC (Ported from chessui.py) ---

        // Global UI state variables
        let canvas, ctx;
        let gameState;
        let validMoves = [];
        let selectedSquare = {}; // e.g., { row: 7, col: 4 }
        let moveLog = [];
        let moveIndex = -1;
        let playerTime = 600;
        let opponentTime = 600;
        let timerRunning = false;
        let lastTimeUpdate = 0;
        let timerInterval;
        
        // DOM Elements
        let playerTimeLabel, opponentTimeLabel, infoPieceName, infoPieceDesc;

        /**
         * Loads all piece images
         * Assumes an 'images' folder in the same directory as the HTML file
         */
        function loadImages() {
            const pieces = ['wP', 'wG', 'wV', 'wA', 'wN', 'wS', 'wB',
                            'bP', 'bG', 'bV', 'bA', 'bN', 'bS', 'bB'];
            const promises = [];
            
            for (const piece of pieces) {
                const img = new Image();
                IMAGES[piece] = img;
                // IMPORTANT: You MUST have an 'images' folder next to this HTML file
                img.src = `images/${piece}.png`; 
                
                const promise = new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => reject(`Failed to load image: ${img.src}`);
                });
                promises.push(promise);
            }
            return Promise.all(promises);
        }

        /**
         * Draws the 9x9 board
         */
        function drawBoard() {
            const colors = ["#f0d9b5", "#b58863"];
            for (let r = 0; r < DIMENSION; r++) {
                for (let c = 0; c < DIMENSION; c++) {
                    const color = colors[(r + c) % 2];
                    ctx.fillStyle = color;
                    ctx.fillRect(c * SQUARE_SIZE, r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
                }
            }
        }

        /**
         * Draws all pieces on the board
         */
        function drawPieces() {
            for (let r = 0; r < DIMENSION; r++) {
                for (let c = 0; c < DIMENSION; c++) {
                    const piece = gameState.board[r][c];
                    if (piece !== "--" && IMAGES[piece]) {
                        // Centering the piece
                        const padding = 2; // Small padding
                        const x = c * SQUARE_SIZE + padding;
                        const y = r * SQUARE_SIZE + padding;
                        const size = SQUARE_SIZE - (padding * 2);
                        ctx.drawImage(IMAGES[piece], x, y, size, size);
                    }
                }
            }
        }
        
        /**
         * Draws dots on valid empty squares (ported)
         */
        function highlightEmptySquares(moves) {
            const dotRadius = SQUARE_SIZE / 6;
            ctx.fillStyle = "#bbbbbb";
            for (const move of moves) {
                if (move.pieceCaptured === "--") {
                    const centerX = move.endCol * SQUARE_SIZE + SQUARE_SIZE / 2;
                    const centerY = move.endRow * SQUARE_SIZE + SQUARE_SIZE / 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, dotRadius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        /**
         * Draws rings on valid capture squares (ported)
         */
        function highlightCaptureSquares(moves) {
            const ringThickness = 3;
            ctx.strokeStyle = "#bbbbbb";
            ctx.lineWidth = ringThickness;
            for (const move of moves) {
                if (move.pieceCaptured !== "--") {
                    const x = move.endCol * SQUARE_SIZE + ringThickness;
                    const y = move.endRow * SQUARE_SIZE + ringThickness;
                    const size = SQUARE_SIZE - (ringThickness * 2);
                    ctx.beginPath();
                    ctx.arc(x + size/2, y + size/2, size/2, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
        }
        
        /**
         * Redraws the entire game state (board, highlights, pieces)
         */
        function drawGameState() {
            drawBoard();
            
            // Highlight moves if a piece is selected
            if (selectedSquare.row !== undefined) {
                const movesForPiece = validMoves.filter(m => m.startRow === selectedSquare.row && m.startCol === selectedSquare.col);
                highlightEmptySquares(movesForPiece);
                // Draw pieces *after* empty dots
                drawPieces();
                // Draw capture rings *after* pieces
                highlightCaptureSquares(movesForPiece);
            } else {
                drawPieces();
            }
        }

        /**
         * Updates the info panel (ported)
         */
        function updateInfoBox(pieceCode) {
            const info = PIECE_INFO[pieceCode] || PIECE_INFO["default"];
            infoPieceName.textContent = info.name;
            infoPieceDesc.textContent = info.desc;
        }

        /**
         * Main click handler for the canvas (ported)
         */
        function onSquareClick(event) {
            if (gameState.checkmate) return; // Game is over

            const rect = canvas.getBoundingClientRect();
            // Scale click coordinates if canvas is resized
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            
            const col = Math.floor(x / SQUARE_SIZE);
            const row = Math.floor(y / SQUARE_SIZE);
            
            const clickedSquare = { row, col };
            const piece = gameState.board[row][col];
            
            if (selectedSquare.row !== undefined) {
                // A piece is already selected
                const selRow = selectedSquare.row;
                const selCol = selectedSquare.col;
                
                // Deselect
                selectedSquare = {}; 
                updateInfoBox('default');
                
                if (clickedSquare.row === selRow && clickedSquare.col === selCol) {
                    drawGameState(); // Just deselect
                    return;
                }

                // Check if it's a valid move
                const move = validMoves.find(m => 
                    m.startRow === selRow && m.startCol === selCol &&
                    m.endRow === row && m.endCol === col
                );

                if (move) {
                    gameState.makeMove(move);
                    moveLog = moveLog.slice(0, moveIndex + 1); // Truncate redo log
                    moveLog.push(move);
                    moveIndex++;
                    
                    if (!timerRunning) {
                        timerRunning = true;
                        lastTimeUpdate = Date.now();
                    }
                    
                    // Get new moves and check for game over
                    validMoves = gameState.getValidMoves(); 
                    if (gameState.checkmate) {
                        timerRunning = false;
                        alert(gameState.whiteToMove ? "Checkmate! White wins." : "Checkmate! Black wins.");
                    }

                }
                
                drawGameState();

            } else {
                // No piece selected, try to select one
                if (piece !== "--" && (piece[0] === 'w' ? gameState.whiteToMove : !gameState.whiteToMove)) {
                    selectedSquare = clickedSquare;
                    updateInfoBox(piece[1]);
                    drawGameState(); // Redraw with highlights
                }
            }
        }
        
        /**
         * Starts a new game (ported)
         */
        function startNewGame() {
            gameState = new GameState();
            validMoves = gameState.getValidMoves();
            selectedSquare = {};
            moveLog = [];
            moveIndex = -1;
            playerTime = 600;
            opponentTime = 600;
            timerRunning = false;
            lastTimeUpdate = Date.now();
            updateInfoBox('default');
            drawGameState();
            updateTimerDisplay();
        }

        /**
         * Undoes the last move (ported)
         */
        function undoMove() {
            if (moveIndex >= 0) {
                gameState.undoMove();
                moveIndex--;
                validMoves = gameState.getValidMoves();
                selectedSquare = {};
                updateInfoBox('default');
                drawGameState();
            }
        }

        /**
         * Redoes the last undone move (ported)
         */
        function redoMove() {
            if (moveIndex < moveLog.length - 1) {
                moveIndex++;
                gameState.makeMove(moveLog[moveIndex]);
                validMoves = gameState.getValidMoves();
                selectedSquare = {};
                updateInfoBox('default');
                drawGameState();
            }
        }
        
        /**
         * Formats time from seconds to MM:SS
         */
        function formatTime(timeInSeconds) {
            const minutes = Math.floor(timeInSeconds / 60);
            const seconds = Math.floor(timeInSeconds % 60);
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        /**
         * Updates the timer labels on screen
         */
        function updateTimerDisplay() {
            playerTimeLabel.textContent = `Player Time: ${formatTime(playerTime)}`;
            opponentTimeLabel.textContent = `Opponent Time: ${formatTime(opponentTime)}`;
        }

        /**
         * Main timer loop (ported)
         */
        function updateTimer() {
            if (!timerRunning) return;
            
            const now = Date.now();
            const elapsed = (now - lastTimeUpdate) / 1000; // in seconds
            lastTimeUpdate = now;
            
            if (gameState.whiteToMove) {
                playerTime -= elapsed;
            } else {
                opponentTime -= elapsed;
            }
            
            if (playerTime <= 0 || opponentTime <= 0) {
                playerTime = Math.max(0, playerTime);
                opponentTime = Math.max(0, opponentTime);
                timerRunning = false;
                alert(playerTime <= 0 ? "Time's up! Black wins." : "Time's up! White wins.");
            }
            
            updateTimerDisplay();
        }

        // --- 4. INITIALIZATION ---

        /**
         * Runs when the page content is loaded
         */
        document.addEventListener("DOMContentLoaded", () => {
            canvas = document.getElementById("chessCanvas");
            if (!canvas) {
                console.error("Canvas element not found!");
                return;
            }
            ctx = canvas.getContext("2d");
            canvas.width = BOARD_WIDTH;
            canvas.height = BOARD_HEIGHT;

            // Get other DOM elements
            playerTimeLabel = document.getElementById("player-time");
            opponentTimeLabel = document.getElementById("opponent-time");
            infoPieceName = document.getElementById("info-piece-name");
            infoPieceDesc = document.getElementById("info-piece-desc");

            // Add button listeners
            document.getElementById("new-game-btn").onclick = startNewGame;
            document.getElementById("undo-btn").onclick = undoMove;
            document.getElementById("redo-btn").onclick = redoMove;
            
            // Add canvas click listener
            canvas.onclick = onSquareClick;

            // Load images and then start the game
            loadImages()
                .then(() => {
                    console.log("Images loaded successfully.");
                    startNewGame(); // Start the first game
                    timerInterval = setInterval(updateTimer, 1000); // Start the timer loop
                })
                .catch(error => {
                    console.error(error);
                    alert("Fatal Error: Could not load piece images. Make sure the 'images' folder is in the same directory as this HTML file.");
                });
        });

    </script>
</body>
</html>
